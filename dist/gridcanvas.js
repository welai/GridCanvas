(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["gridcanvas"] = factory();
	else
		root["gridcanvas"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js!./src/style.css":
/*!*************************************************!*\
  !*** ./node_modules/css-loader!./src/style.css ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".grid-button {\\n    border-radius: 50%;\\n    border-color: transparent;\\n    outline: none;\\n    z-index: 10;\\n    transition: all 500ms;\\n}\\n.grid-button:hover {\\n    opacity: 1;\\n    box-shadow: 0px 15px 25px #00000022;\\n}\\n.grid-button:not(:hover) {\\n    opacity: 0.7;\\n    box-shadow: 0px 5px 10px #00000033;\\n}\\n.grid-button:active {\\n    transform: scale(1.1, 1.1);\\n    transition: all 600ms;\\n}\\n.grid-button .icon {\\n    fill: white;\\n}\\n.grid-button.grid-on {\\n    background-color: #27A2C5;   \\n}\\n.grid-button.grid-off {\\n    background-color: #aaaaaa;\\n}\\n\\n.hbar-container:hover {\\n    opacity: 1;\\n    transition: all 500ms;\\n}\\n.hbar-container:not(:hover) {\\n    opacity: 0.5;\\n    transition: all 500ms;\\n}\\n.vbar-container:hover {\\n    opacity: 1;\\n    transition: all 500ms;\\n}\\n.vbar-container:not(:hover) {\\n    opacity: 0.5;\\n    transition: all 500ms;\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack://gridcanvas/./src/style.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//# sourceURL=webpack://gridcanvas/./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/dual-range-bar/dist/dual-range-bar.min.js":
/*!****************************************************************!*\
  !*** ./node_modules/dual-range-bar/dist/dual-range-bar.min.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(e,t){ true?module.exports=t():undefined}(window,function(){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var r in e)n.d(i,r,function(t){return e[t]}.bind(null,r));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=7)}([function(e,t){e.exports=function(e){var t=[];return t.toString=function(){return this.map(function(t){var n=function(e,t){var n=e[1]||\"\",i=e[3];if(!i)return n;if(t&&\"function\"==typeof btoa){var r=function(e){return\"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(e))))+\" */\"}(i),a=i.sources.map(function(e){return\"/*# sourceURL=\"+i.sourceRoot+e+\" */\"});return[n].concat(a).concat([r]).join(\"\\n\")}return[n].join(\"\\n\")}(t,e);return t[2]?\"@media \"+t[2]+\"{\"+n+\"}\":n}).join(\"\")},t.i=function(e,n){\"string\"==typeof e&&(e=[[null,e,\"\"]]);for(var i={},r=0;r<this.length;r++){var a=this[r][0];\"number\"==typeof a&&(i[a]=!0)}for(r=0;r<e.length;r++){var o=e[r];\"number\"==typeof o[0]&&i[o[0]]||(n&&!o[2]?o[2]=n:n&&(o[2]=\"(\"+o[2]+\") and (\"+n+\")\"),t.push(o))}},t}},function(e,t,n){var i={},r=function(e){var t;return function(){return void 0===t&&(t=e.apply(this,arguments)),t}}(function(){return window&&document&&document.all&&!window.atob}),a=function(e){var t={};return function(e,n){if(\"function\"==typeof e)return e();if(void 0===t[e]){var i=function(e,t){return t?t.querySelector(e):document.querySelector(e)}.call(this,e,n);if(window.HTMLIFrameElement&&i instanceof window.HTMLIFrameElement)try{i=i.contentDocument.head}catch(e){i=null}t[e]=i}return t[e]}}(),o=null,s=0,l=[],u=n(4);function c(e,t){for(var n=0;n<e.length;n++){var r=e[n],a=i[r.id];if(a){a.refs++;for(var o=0;o<a.parts.length;o++)a.parts[o](r.parts[o]);for(;o<r.parts.length;o++)a.parts.push(g(r.parts[o],t))}else{var s=[];for(o=0;o<r.parts.length;o++)s.push(g(r.parts[o],t));i[r.id]={id:r.id,refs:1,parts:s}}}}function f(e,t){for(var n=[],i={},r=0;r<e.length;r++){var a=e[r],o=t.base?a[0]+t.base:a[0],s={css:a[1],media:a[2],sourceMap:a[3]};i[o]?i[o].parts.push(s):n.push(i[o]={id:o,parts:[s]})}return n}function d(e,t){var n=a(e.insertInto);if(!n)throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");var i=l[l.length-1];if(\"top\"===e.insertAt)i?i.nextSibling?n.insertBefore(t,i.nextSibling):n.appendChild(t):n.insertBefore(t,n.firstChild),l.push(t);else if(\"bottom\"===e.insertAt)n.appendChild(t);else{if(\"object\"!=typeof e.insertAt||!e.insertAt.before)throw new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");var r=a(e.insertAt.before,n);n.insertBefore(t,r)}}function p(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var t=l.indexOf(e);t>=0&&l.splice(t,1)}function h(e){var t=document.createElement(\"style\");if(void 0===e.attrs.type&&(e.attrs.type=\"text/css\"),void 0===e.attrs.nonce){var i=function(){0;return n.nc}();i&&(e.attrs.nonce=i)}return v(t,e.attrs),d(e,t),t}function v(e,t){Object.keys(t).forEach(function(n){e.setAttribute(n,t[n])})}function g(e,t){var n,i,r,a;if(t.transform&&e.css){if(!(a=t.transform(e.css)))return function(){};e.css=a}if(t.singleton){var l=s++;n=o||(o=h(t)),i=b.bind(null,n,l,!1),r=b.bind(null,n,l,!0)}else e.sourceMap&&\"function\"==typeof URL&&\"function\"==typeof URL.createObjectURL&&\"function\"==typeof URL.revokeObjectURL&&\"function\"==typeof Blob&&\"function\"==typeof btoa?(n=function(e){var t=document.createElement(\"link\");return void 0===e.attrs.type&&(e.attrs.type=\"text/css\"),e.attrs.rel=\"stylesheet\",v(t,e.attrs),d(e,t),t}(t),i=function(e,t,n){var i=n.css,r=n.sourceMap,a=void 0===t.convertToAbsoluteUrls&&r;(t.convertToAbsoluteUrls||a)&&(i=u(i));r&&(i+=\"\\n/*# sourceMappingURL=data:application/json;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+\" */\");var o=new Blob([i],{type:\"text/css\"}),s=e.href;e.href=URL.createObjectURL(o),s&&URL.revokeObjectURL(s)}.bind(null,n,t),r=function(){p(n),n.href&&URL.revokeObjectURL(n.href)}):(n=h(t),i=function(e,t){var n=t.css,i=t.media;i&&e.setAttribute(\"media\",i);if(e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}.bind(null,n),r=function(){p(n)});return i(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;i(e=t)}else r()}}e.exports=function(e,t){if(\"undefined\"!=typeof DEBUG&&DEBUG&&\"object\"!=typeof document)throw new Error(\"The style-loader cannot be used in a non-browser environment\");(t=t||{}).attrs=\"object\"==typeof t.attrs?t.attrs:{},t.singleton||\"boolean\"==typeof t.singleton||(t.singleton=r()),t.insertInto||(t.insertInto=\"head\"),t.insertAt||(t.insertAt=\"bottom\");var n=f(e,t);return c(n,t),function(e){for(var r=[],a=0;a<n.length;a++){var o=n[a];(s=i[o.id]).refs--,r.push(s)}e&&c(f(e,t),t);for(a=0;a<r.length;a++){var s;if(0===(s=r[a]).refs){for(var l=0;l<s.parts.length;l++)s.parts[l]();delete i[s.id]}}}};var _=function(){var e=[];return function(t,n){return e[t]=n,e.filter(Boolean).join(\"\\n\")}}();function b(e,t,n,i){var r=n?\"\":i.css;if(e.styleSheet)e.styleSheet.cssText=_(t,r);else{var a=document.createTextNode(r),o=e.childNodes;o[t]&&e.removeChild(o[t]),o.length?e.insertBefore(a,o[t]):e.appendChild(a)}}},function(e,t,n){var i=n(3);\"string\"==typeof i&&(i=[[e.i,i,\"\"]]);var r={hmr:!0,transform:void 0,insertInto:void 0};n(1)(i,r);i.locals&&(e.exports=i.locals)},function(e,t,n){(e.exports=n(0)(!1)).push([e.i,\".dual-background, .dual-container,\\n.dual-slider {\\n    -webkit-touch-callout: none;\\n    -webkit-user-select: none;\\n    -khtml-user-select: none;\\n    -moz-user-select: none;\\n    -ms-user-select: none;\\n    user-select: none;\\n    touch-action: none;\\n}\\n\\n.dual-background {\\n    width: 100%;\\n    height: 100%;\\n    position: relative;\\n    margin: auto;\\n    z-index: 1;\\n}\\n.dual-horizontal.dual-background {\\n    top: 50%;\\n    transform: translateY(-50%);\\n}\\n\\n.dual-range, .dual-container {\\n    display: inline-block;\\n    position: absolute;\\n}\\n.dual-range.dual-container {\\n    z-index: 2;\\n}\\n.dual-first.dual-container,\\n.dual-last.dual-container {\\n    z-index: 3;\\n}\\n.dual-vertical.dual-container {\\n    text-align: center;\\n}\\n\\n.dual-slider {\\n    top: 50%;\\n    margin: auto;\\n}\\n.dual-horizontal.dual-first.dual-slider,\\n.dual-horizontal.dual-last.dual-slider {\\n    position: absolute;\\n    transform: translateX(-50%) translateY(-50%);\\n    cursor: ew-resize;\\n}\\n.dual-horizontal.dual-range.dual-slider {\\n    position: absolute;\\n    top: 50%;\\n    transform: translateY(-50%);\\n    width: 100%;\\n    cursor: move;\\n}\\n.dual-vertical.dual-slider {\\n    position: relative;\\n    cursor: ns-resize;\\n}\\n.dual-vertical.dual-range.dual-slider {\\n    position: absolute;\\n    top: 0%;\\n    transform: translateX(-50%);\\n    height: 100%;\\n    cursor: move;\\n}\",\"\"])},function(e,t){e.exports=function(e){var t=\"undefined\"!=typeof window&&window.location;if(!t)throw new Error(\"fixUrls requires window.location\");if(!e||\"string\"!=typeof e)return e;var n=t.protocol+\"//\"+t.host,i=n+t.pathname.replace(/\\/[^\\/]*$/,\"/\");return e.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi,function(e,t){var r,a=t.trim().replace(/^\"(.*)\"$/,function(e,t){return t}).replace(/^'(.*)'$/,function(e,t){return t});return/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(a)?e:(r=0===a.indexOf(\"//\")?a:0===a.indexOf(\"/\")?n+a:i+a.replace(/^\\.\\//,\"\"),\"url(\"+JSON.stringify(r)+\")\")})}},function(e,t,n){var i=n(6);\"string\"==typeof i&&(i=[[e.i,i,\"\"]]);var r={hmr:!0,transform:void 0,insertInto:void 0};n(1)(i,r);i.locals&&(e.exports=i.locals)},function(e,t,n){(e.exports=n(0)(!1)).push([e.i,\".dual-slider {\\n    background-color: #1E88A8;\\n    outline: none;\\n    border: none;\\n    width: 20px;\\n    height: 20px;\\n    border-radius: 10px;\\n}\\n.dual-first.dual-slider:not(:active),\\n.dual-last.dual-slider:not(:active) {\\n    transition: all 250ms;\\n}\\n.dual-first.dual-horizontal.dual-slider:active,\\n.dual-last.dual-horizontal.dual-slider:active {\\n    transform: scale(1.2,1.2) translateX(-40%) translateY(-40%);\\n    transition: all 100ms;\\n}\\n.dual-first.dual-vertical.dual-slider:active,\\n.dual-last.dual-vertical.dual-slider:active {\\n    transform: scale(1.2,1.2);\\n    transition: all 100ms;\\n}\\n.dual-range.dual-slider:not(:active) {\\n    background-color: #7DB9DE;\\n    transition: all 1000ms;\\n}\\n.dual-range.dual-slider:active {\\n    background-color: #27A2C5;\\n    transition: all 500ms;\\n}\\n.dual-horizontal.dual-range.dual-slider {\\n    height: 12px;\\n}\\n.dual-vertical.dual-range.dual-slider {\\n    width: 12px;\\n}\\n\\n.dual-background {\\n    background-color: rgba(200, 200, 200, 0.7);\\n    border-radius: 4px;\\n}\\n.dual-horizontal.dual-background {\\n    height: 8px;\\n}\\n.dual-vertical.dual-background {\\n    width: 8px;\\n}\\n\",\"\"])},function(e,t,n){\"use strict\";n.r(t);n(2),n(5);var i={hrangeClassName:\"dual-hrange\",vrangeClassName:\"dual-vrange\",backgroundClass:\"dual-background\",firstClass:\"dual-first\",rangeClass:\"dual-range\",lastClass:\"dual-last\",containerClass:\"dual-container\",sliderClass:\"dual-slider\",horizontalClass:\"dual-horizontal\",verticalClass:\"dual-vertical\",lowerBoundAtt:\"lower-bound\",upperBoundAtt:\"upper-bound\",minDiffAtt:\"min-difference\",maxDiffAtt:\"max-difference\"};function r(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}var a=function(){function e(t){var n=this;if(function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),\"string\"==typeof t&&(t=document.getElementById(t)),this.htmlElement=t,e.dict||(e.dict={}),!e.dict[t.id]){e.dict[t.id]=this;var r=this.dualRangeElement=t;r.style.textAlign=\"left\",this.backgroundDiv=document.createElement(\"div\"),this.backgroundDiv.classList.add(i.backgroundClass),this.firstSliderContainer=document.createElement(\"div\"),this.firstSliderContainer.classList.add(i.firstClass,i.containerClass),this.firstSlider=this.firstSliderContainer.appendChild(document.createElement(\"button\")),this.firstSlider.classList.add(i.firstClass,i.sliderClass),this.rangeSliderContainer=document.createElement(\"div\"),this.rangeSliderContainer.classList.add(i.rangeClass,i.containerClass),this.rangeSlider=this.rangeSliderContainer.appendChild(document.createElement(\"button\")),this.rangeSlider.classList.add(i.rangeClass,i.sliderClass),this.lastSliderContainer=document.createElement(\"div\"),this.lastSliderContainer.classList.add(i.lastClass,i.containerClass),this.lastSlider=this.lastSliderContainer.appendChild(document.createElement(\"button\")),this.lastSlider.classList.add(i.lastClass,i.sliderClass),this._lowerBound=a(i.lowerBoundAtt,0),this._upperBound=a(i.upperBoundAtt,1),this._relativeLower=0,this._relativeUpper=1,this._setLowerBoundCallbacks=[],this._setUpperBoundCallbacks=[],this._setLowerRangeCallbacks=[],this._setUpperRangeCallbacks=[],this._minDifference=a(i.minDiffAtt,.1),this._maxDifference=a(i.maxDiffAtt,1),this._relativeMinDifference=Math.abs(this._minDifference/(this._upperBound-this._lowerBound)),this._relativeMaxDifference=Math.abs(this._maxDifference/(this._upperBound-this._lowerBound)),this._relativeUpper-this._relativeLower>this._relativeMaxDifference&&(this._relativeUpper=this._relativeLower+this._relativeMaxDifference),(this._relativeMinDifference<.05||this._relativeMinDifference>1)&&(console.warn(\"Invalid setting of \".concat(i.minDiffAtt,\", restored to default 0.1\")),this._relativeMinDifference=.1,this._minDifference=_relativeMinDifference*(this._upperBound-this._lowerBound)),(this._relativeMaxDifference<.05||this._relativeMaxDifference>1)&&(console.warn(\"Invalid setting of \".concat(i.maxDiffAtt,\", restored to default 0.1\")),this._relativeMaxDifference=.1,this._maxDifference=_relativeMaxDifference*(this._upperBound-this._lowerBound)),this._setMinDifferenceChangeCallbacks=[],this._setMaxDifferenceChangeCallbacks=[],this._setRelativeMinDifferenceChangeCallbacks=[],this._setRelativeMaxDifferenceChangeCallbacks=[],window.addEventListener(\"resize\",function(){n.updatePositions.call(n)}),window.addEventListener(\"scroll\",function(){n.updatePositions.call(n)}),document.addEventListener(\"touchstart\",function(){n.updatePositions.call(n)}),document.addEventListener(\"touchmove\",function(){n.updatePositions.call(n)}),document.addEventListener(\"touchend\",function(){setTimeout(n.updatePositions.call(n),500)}),r.addEventListener(\"change\",function(){n.updatePositions.call(n)}),this._bindMouseEvents(),this.addLowerRangeChangeCallback(function(e){n.updateFirstPosition(e),n.updateRange(e,null)}),this.addUpperRangeChangeCallback(function(e){n.updateLastPosition(e),n.updateRange(null,e)}),this.addLowerBoundChangeCallback(function(e){n.updatePositions()}),this.addUpperBoundChangeCallback(function(e){n.updatePositions()})}function a(e,t){var n=r.getAttribute(e);return n&&(n=Number.parseFloat(n),!isNaN(n))?n:t}}return function(e,t,n){t&&r(e.prototype,t),n&&r(e,n)}(e,[{key:\"setLowerBound\",value:function(e){this._lowerBound=e,this.updatePositions()}},{key:\"setUpperBound\",value:function(e){this._upperBound=e,this.updatePositions()}},{key:\"setLowerRange\",value:function(e){this._relativeLower=(e-this._lowerBound)/(this._upperBound-this._lowerBound),this.updatePositions()}},{key:\"setUpperRange\",value:function(e){this._relativeUpper=(e-this._lowerBound)/(this._upperBound-this._lowerBound),this.updatePositions()}},{key:\"setMinDifference\",value:function(e){this._minDifference=e,this._relativeMinDifference=Math.abs(e/(this._upperBound-this._lowerBound)),this.updatePositions()}},{key:\"setMaxDifference\",value:function(e){this._maxDifference=e,this._relativeMaxDifference=Math.abs(e/(this._upperBound-this._lowerBound)),this.updatePositions()}},{key:\"setRelativeMaxDifference\",value:function(e){this._relativeMaxDifference=e,this._maxDifference=(this._upperBound-this.lowerBound)*e,this.updatePositions()}},{key:\"setRelativeMaxDifference\",value:function(e){this._relativeMaxDifference=e,this._maxDifference=(this._upperBound-this.lowerBound)*e,this.updatePositions()}},{key:\"setRelativeLower\",value:function(e){this._relativeLower=e,this.updatePositions()}},{key:\"setRelativeUpper\",value:function(e){this._relativeUpper=e,this.updatePositions()}},{key:\"_bindMouseEvents\",value:function(){var e=this;this._latestMouseActiveValue=null,this._firstMouseDown=!1,this._rangeMouseDown=!1,this._lastMouseDown=!1,this._firstMouseOn=!1,this._rangeMouseOn=!1,this._lastMouseOn=!1,this.firstSlider.addEventListener(\"mouseenter\",function(t){e._firstMouseOn=!0}),this.firstSlider.addEventListener(\"touchstart\",function(t){t.preventDefault(),e._firstMouseOn=!0}),this.rangeSlider.addEventListener(\"mouseenter\",function(t){e._rangeMouseOn=!0}),this.rangeSlider.addEventListener(\"touchstart\",function(t){t.preventDefault(),e._rangeMouseOn=!0}),this.lastSlider.addEventListener(\"mouseenter\",function(t){e._lastMouseOn=!0}),this.lastSlider.addEventListener(\"touchstart\",function(t){t.preventDefault(),e._lastMouseOn=!0}),this.firstSlider.addEventListener(\"mouseleave\",function(t){e._firstMouseOn=!1}),this.firstSlider.addEventListener(\"touchend\",function(t){e._firstMouseOn=!1}),this.rangeSlider.addEventListener(\"mouseleave\",function(t){e._rangeMouseOn=!1}),this.rangeSlider.addEventListener(\"touchend\",function(t){e._rangeMouseOn=!1}),this.lastSlider.addEventListener(\"mouseleave\",function(t){e._lastMouseOn=!1}),this.lastSlider.addEventListener(\"touchend\",function(t){e._lastMouseOn=!1});var t=function(t){e._latestMouseActiveValue=e.getMouseValue(t);var n=[e._firstMouseOn,e._rangeMouseOn,e._lastMouseOn];e._firstMouseDown=n[0],e._rangeMouseDown=n[1],e._lastMouseDown=n[2]};window.addEventListener(\"mousedown\",t),window.addEventListener(\"touchstart\",t);var n=function(t){[\"_firstMouseDown\",\"_rangeMouseDown\",\"_lastMouseDown\"].map(function(t){e[t]=!1})};window.addEventListener(\"mouseup\",n),window.addEventListener(\"touchend\",n);var i=function(t){e._firstMouseDown&&((n=e.getMouseValue(t))<0?e.relativeLower=0:n>e._relativeUpper-e._relativeMinDifference?n<=1-e.relativeMinDifference?(e.relativeLower=n,e.relativeUpper=n+e._relativeMinDifference):e._relativeLower=e._relativeUpper-e._relativeMinDifference:n<e._relativeUpper-e._relativeMaxDifference?(e.relativeLower=n,e.relativeUpper=n+e._relativeMaxDifference):e.relativeLower=n);if(e._rangeMouseDown){var n,i=(n=e.getMouseValue(t))-e._latestMouseActiveValue;e._latestMouseActiveValue=n,e._relativeLower+i<0?(e.relativeUpper=e._relativeUpper-e._relativeLower,e.relativeLower=0):e._relativeUpper+i>1?(e.relativeLower=1-(e._relativeUpper-e._relativeLower),e.relativeUpper=1):(e.relativeLower=e._relativeLower+i,e.relativeUpper=e._relativeUpper+i)}e._lastMouseDown&&((n=e.getMouseValue(t))>1?e.relativeUpper=1:n<e._relativeLower+e._relativeMinDifference?n>=e._relativeMinDifference?(e.relativeUpper=n,e.relativeLower=n-e._relativeMinDifference):e.relativeUpper=e._relativeLower+e._relativeMinDifference:n>e._relativeLower+e._relativeMaxDifference?(e.relativeUpper=n,e.relativeLower=n-e._relativeMaxDifference):e.relativeUpper=n)};window.addEventListener(\"mousemove\",i),window.addEventListener(\"touchmove\",i);var r=function(t){t.preventDefault();var n=e.getMouseValue(t),i=(t.wheelDelta||120*-t.detail||120*-t.deltaY)/1e3,r=e._relativeLower+(n-e._relativeLower)*i,a=e._relativeUpper-(e._relativeUpper-n)*i;r<0&&(r=0),a>1&&(a=1),a-r<e._relativeMinDifference?(r=a-e._relativeMinDifference)<0&&(r=0,a=e._relativeMinDifference):a-r>e._relativeMaxDifference&&(r=a-e._relativeMaxDifference,a>1&&(a=1,r=1-e._relativeMaxDifference)),e.relativeLower=r,e.relativeUpper=a};this.rangeSlider.addEventListener(\"mousewheel\",r),this.rangeSlider.addEventListener(\"DOMMouseScroll\",r);var a=function(t){t.preventDefault();var n=(-t.wheelDelta||120*t.detail||120*t.deltaY)/2500,i=e._relativeLower+n,r=e._relativeUpper+n;i<0&&(i=0,r=e._relativeUpper-e._relativeLower),r>1&&(r=1,i=1-(e._relativeUpper-e._relativeLower)),e.relativeLower=i,e.relativeUpper=r};this.backgroundDiv.addEventListener(\"mousewheel\",a),this.backgroundDiv.addEventListener(\"DOMMouseScroll\",a)}},{key:\"addLowerRangeChangeCallback\",value:function(e){this._setLowerRangeCallbacks.push(e)}},{key:\"addUpperRangeChangeCallback\",value:function(e){this._setUpperRangeCallbacks.push(e)}},{key:\"addLowerBoundChangeCallback\",value:function(e){this._setLowerBoundCallbacks.push(e)}},{key:\"addUpperBoundChangeCallback\",value:function(e){this._setUpperBoundCallbacks.push(e)}},{key:\"addMinDifferenceChangeCallback\",value:function(e){this._setMinDifferenceChangeCallbacks.push(e)}},{key:\"addMaxDifferenceChangeCallback\",value:function(e){this._setMaxDifferenceChangeCallbacks.push(e)}},{key:\"addRelativeMinDifferenceChangeCallback\",value:function(e){this._setRelativeMinDifferenceChangeCallbacks.push(e)}},{key:\"addRelativeMaxDifferenceChangeCallback\",value:function(e){this._setRelativeMaxDifferenceChangeCallbacks.push(e)}},{key:\"removeLowerRangeChangeCallback\",value:function(e){var t=this._setLowerRangeCallbacks,n=t.indexOf(e);-1!==n&&t.splice(n,1)}},{key:\"removeUpperRangeChangeCallback\",value:function(e){var t=this._setUpperRangeCallbacks,n=t.indexOf(e);-1!==n&&t.splice(n,1)}},{key:\"removeLowerBoundChangeCallback\",value:function(e){var t=this._setLowerBoundCallbacks,n=t.indexOf(e);-1!==n&&t.splice(n,1)}},{key:\"removeUpperBoundChangeCallback\",value:function(e){var t=this._setUpperBoundCallbacks,n=t.indexOf(e);-1!==n&&t.splice(n,1)}},{key:\"removeMinDifferenceChangeCallback\",value:function(e){var t=this._setMinDifferenceChangeCallbacks,n=t.indexOf(e);-1!==n&&t.splice(n,1)}},{key:\"removeMaxDifferenceChangeCallback\",value:function(e){var t=this._setMaxDifferenceChangeCallbacks,n=t.indexOf(e);-1!==n&&t.splice(n,1)}},{key:\"removeRelativeMinDifferenceChangeCallback\",value:function(e){var t=this._setRelativeMinDifferenceChangeCallbacks,n=t.indexOf(e);-1!==n&&t.splice(n,1)}},{key:\"removeRelativeMaxDifferenceChangeCallback\",value:function(e){var t=this._setRelativeMaxDifferenceChangeCallbacks,n=t.indexOf(e);-1!==n&&t.splice(n,1)}},{key:\"createInHrangeElements\",value:function(){this.dualRangeElement.appendChild(this.backgroundDiv),this.dualRangeElement.appendChild(this.firstSliderContainer),this.dualRangeElement.appendChild(this.rangeSliderContainer),this.dualRangeElement.appendChild(this.lastSliderContainer)}},{key:\"updatePositions\",value:function(){this.updateFirstPosition(this._relativeLower),this.updateRange(this._relativeLower,this._relativeUpper),this.updateLastPosition(this._relativeUpper)}},{key:\"updateFirstPosition\",value:function(e){}},{key:\"updateRange\",value:function(e,t){}},{key:\"updateLastPosition\",value:function(e){}},{key:\"getMouseValue\",value:function(e){return 0}},{key:\"lowerBound\",get:function(){return this._lowerBound},set:function(e){this._lowerBound=e,this._setLowerBoundCallbacks.forEach(function(t){t.apply(window,[e])}),this.updatePositions()}},{key:\"upperBound\",get:function(){return this._upperBound},set:function(e){this._upperBound=e,this._setUpperBoundCallbacks.forEach(function(t){t.apply(window,[e])}),this.updatePositions()}},{key:\"lowerRange\",get:function(){return this._relativeLower*(this._upperBound-this._lowerBound)+this._lowerBound},set:function(e){this._relativeLower=(e-this._lowerBound)/(this._upperBound-this._lowerBound),this._setLowerRangeCallbacks.forEach(function(t){t.apply(window,[e])}),this.updatePositions()}},{key:\"upperRange\",get:function(){return this._relativeUpper*(this._upperBound-this._lowerBound)+this._lowerBound},set:function(e){this._relativeUpper=(e-this._lowerBound)/(this._upperBound-this._lowerBound),this._setUpperRangeCallbacks.forEach(function(t){t.apply(window,[e])}),this.updatePositions()}},{key:\"minDifference\",get:function(){return this._minDifference},set:function(e){this._minDifference=e,this._relativeMinDifference=Math.abs(e/(this._upperBound-this._lowerBound)),this._setMinDifferenceChangeCallbacks.forEach(function(t){t.apply(window,[e])}),this.updatePositions()}},{key:\"maxDifference\",get:function(){return this._maxDifference},set:function(e){this._maxDifference=e,this._relativeMaxDifference=Math.abs(e/(this._upperBound-this._lowerBound)),this._setMaxDifferenceChangeCallbacks.forEach(function(t){t.apply(window,[e])}),this._relativeUpper-this._relativeLower>this._relativeMaxDifference&&(this.relativeUpper=this._relativeLower+this._relativeMaxDifference),this.updatePositions()}},{key:\"relativeMinDifference\",get:function(){return this._relativeMinDifference},set:function(e){this._relativeMinDifference=e,this._minDifference=(this._upperBound-this.lowerBound)*e,this._setRelativeMinDifferenceChangeCallbacks.forEach(function(t){t.apply(window,[e])}),this.updatePositions()}},{key:\"relativeMaxDifference\",get:function(){return this._relativeMaxDifference},set:function(e){this._relativeMaxDifference=e,this._maxDifference=(this._upperBound-this.lowerBound)*e,this._setRelativeMaxDifferenceChangeCallbacks.forEach(function(t){t.apply(window,[e])}),this._relativeUpper-this._relativeLower>this._relativeMaxDifference&&(this.relativeUpper=this._relativeLower+this._relativeMaxDifference),this.updatePositions()}},{key:\"relativeLower\",get:function(){return this._relativeLower},set:function(e){this._relativeLower=e,this._setLowerRangeCallbacks.forEach(function(t){t.apply(window,[e])}),this.updatePositions()}},{key:\"relativeUpper\",get:function(){return this._relativeUpper},set:function(e){this._relativeUpper=e,this._setUpperRangeCallbacks.forEach(function(t){t.apply(window,[e])}),this.updatePositions()}}],[{key:\"getObject\",value:function(t){if(e.dict||(e.dict={}),void 0!==e.dict[t])return e.dict[t];var n=document.getElementById(t);return n.classList.contains(dualHrangeClassName)?new DualHRange(t):n.classList.contains(dualVrangeClassName)?new DualVRange(t):null}},{key:\"_getOffsetY\",value:function(e){var t=e.getBoundingClientRect(),n=document.body,i=document.documentElement,r=i.clientTop||n.clientTop||0,a=window.pageYOffset||i.scrollTop||n.scrollTop;return Math.round(t.top+a-r)}},{key:\"_getOffsetX\",value:function(e){var t=e.getBoundingClientRect(),n=document.body,i=document.documentElement,r=i.clientLeft||n.clientLeft||0,a=window.pageXOffset||i.scrollLeft||n.scrollLeft;return Math.round(t.left+a-r)}}]),e}();function o(e){return(o=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function s(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function l(e,t){return!t||\"object\"!==o(t)&&\"function\"!=typeof t?u(e):t}function u(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}function c(e,t){return(c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function f(e,t,n){return(f=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var i=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=d(e)););return e}(e,t);if(i){var r=Object.getOwnPropertyDescriptor(i,t);return r.get?r.get.call(n):r.value}})(e,t,n||e)}function d(e){return(d=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var p=function(e){function t(e){var n;return function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,t),n=l(this,d(t).call(this,e)),a.dict[e.id]?l(n):([n.backgroundDiv,n.firstSliderContainer,n.firstSlider,n.rangeSliderContainer,n.rangeSlider,n.lastSliderContainer,n.lastSlider].forEach(function(e){return e.classList.add(i.horizontalClass)}),f(d(t.prototype),\"createInHrangeElements\",u(n)).call(u(n)),f(d(t.prototype),\"updatePositions\",u(n)).call(u(n)),n)}return function(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&c(e,t)}(t,a),function(e,t,n){t&&s(e.prototype,t),n&&s(e,n)}(t,[{key:\"_updateHorizontalPosition\",value:function(e,t){var n=this.dualRangeElement.clientWidth,i=this.dualRangeElement.clientHeight,r=e*n-this.firstSliderContainer.clientWidth/2;t.style.top=\"0px\",t.style.left=\"\".concat(r,\"px\"),t.style.height=\"\".concat(i,\"px\")}},{key:\"updateFirstPosition\",value:function(e){this._updateHorizontalPosition(e,this.firstSliderContainer)}},{key:\"updateLastPosition\",value:function(e){this._updateHorizontalPosition(e,this.lastSliderContainer)}},{key:\"updateRange\",value:function(e,t){if(\"number\"==typeof e&&!isNaN(e)){var n=this.rangeSliderContainer.offsetLeft+this.rangeSliderContainer.clientWidth,i=e*this.dualRangeElement.clientWidth,r=n-i;this.rangeSliderContainer.style.left=\"\".concat(i,\"px\"),this.rangeSliderContainer.style.width=\"\".concat(r,\"px\")}if(\"number\"==typeof t&&!isNaN(t)){var a=this.rangeSliderContainer.offsetLeft,o=t*this.dualRangeElement.clientWidth-a;this.rangeSliderContainer.style.width=\"\".concat(o,\"px\")}this.rangeSliderContainer.style.top=\"0px\",this.rangeSliderContainer.style.height=\"\".concat(this.dualRangeElement.clientHeight,\"px\")}},{key:\"getMouseValue\",value:function(e){return((e.touches?e.touches.item(0).pageX:e.pageX)-a._getOffsetX(this.dualRangeElement))/this.dualRangeElement.clientWidth}}],[{key:\"getObject\",value:function(e){return a.dict||(a.dict={}),void 0!==a.dict[e]?a.dict[e]:new t(e)}}]),t}();function h(e){return(h=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function v(e,t){for(var n=0;n<t.length;n++){var i=t[n];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function g(e,t){return!t||\"object\"!==h(t)&&\"function\"!=typeof t?_(e):t}function _(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}function b(e,t){return(b=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function y(e,t,n){return(y=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var i=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=w(e)););return e}(e,t);if(i){var r=Object.getOwnPropertyDescriptor(i,t);return r.get?r.get.call(n):r.value}})(e,t,n||e)}function w(e){return(w=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var m=function(e){function t(e){var n;return function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,t),n=g(this,w(t).call(this,e)),a.dict[e.id]?g(n):([n.backgroundDiv,n.firstSliderContainer,n.firstSlider,n.rangeSliderContainer,n.rangeSlider,n.lastSliderContainer,n.lastSlider].forEach(function(e){return e.classList.add(i.verticalClass)}),y(w(t.prototype),\"createInHrangeElements\",_(n)).call(_(n)),y(w(t.prototype),\"updatePositions\",_(n)).call(_(n)),n)}return function(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&b(e,t)}(t,a),function(e,t,n){t&&v(e.prototype,t),n&&v(e,n)}(t,[{key:\"_updateVerticalPosition\",value:function(e,t){var n=this.dualRangeElement.clientWidth,i=e*this.dualRangeElement.clientHeight-this.firstSliderContainer.clientHeight/2;t.style.top=\"\".concat(i,\"px\"),t.style.left=\"0px\",t.style.width=\"\".concat(n,\"px\")}},{key:\"updateFirstPosition\",value:function(e){this._updateVerticalPosition(e,this.firstSliderContainer)}},{key:\"updateLastPosition\",value:function(e){this._updateVerticalPosition(e,this.lastSliderContainer)}},{key:\"updateRange\",value:function(e,t){if(\"number\"==typeof e&&!isNaN(e)){var n=this.rangeSliderContainer.offsetTop+this.rangeSliderContainer.clientHeight,i=e*this.dualRangeElement.clientHeight,r=n-i;this.rangeSliderContainer.style.top=\"\".concat(i,\"px\"),this.rangeSliderContainer.style.height=\"\".concat(r,\"px\")}if(\"number\"==typeof t&&!isNaN(t)){var a=this.rangeSliderContainer.offsetTop,o=t*this.dualRangeElement.clientHeight-a;this.rangeSliderContainer.style.height=\"\".concat(o,\"px\")}this.rangeSliderContainer.style.left=\"0px\",this.rangeSliderContainer.style.width=\"\".concat(this.dualRangeElement.clientWidth,\"px\")}},{key:\"getMouseValue\",value:function(e){return((e.touches?e.touches.item(0).pageY:e.pageY)-a._getOffsetY(this.dualRangeElement))/this.dualRangeElement.clientHeight}}],[{key:\"getObject\",value:function(e){return a.dict||(a.dict={}),void 0!==a.dict[e]?a.dict[e]:new t(e)}}]),t}();n.d(t,\"HRange\",function(){return C}),n.d(t,\"VRange\",function(){return k}),window.addEventListener(\"load\",function(e){for(var t=document.getElementsByClassName(i.hrangeClassName),n=document.getElementsByClassName(i.vrangeClassName),r=0;r<t.length;r++)new p(t[r]);for(var a=0;a<n.length;a++)new m(n[a])}),window.dual={HRange:p,VRange:m};var C=p,k=m}])});\n\n//# sourceURL=webpack://gridcanvas/./node_modules/dual-range-bar/dist/dual-range-bar.min.js?");

/***/ }),

/***/ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = (function () {\n    if (typeof Map !== 'undefined') {\n        return Map;\n    }\n\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\n    function getIndex(arr, key) {\n        var result = -1;\n\n        arr.some(function (entry, index) {\n            if (entry[0] === key) {\n                result = index;\n\n                return true;\n            }\n\n            return false;\n        });\n\n        return result;\n    }\n\n    return (function () {\n        function anonymous() {\n            this.__entries__ = [];\n        }\n\n        var prototypeAccessors = { size: { configurable: true } };\n\n        /**\r\n         * @returns {boolean}\r\n         */\n        prototypeAccessors.size.get = function () {\n            return this.__entries__.length;\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\n        anonymous.prototype.get = function (key) {\n            var index = getIndex(this.__entries__, key);\n            var entry = this.__entries__[index];\n\n            return entry && entry[1];\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.set = function (key, value) {\n            var index = getIndex(this.__entries__, key);\n\n            if (~index) {\n                this.__entries__[index][1] = value;\n            } else {\n                this.__entries__.push([key, value]);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.delete = function (key) {\n            var entries = this.__entries__;\n            var index = getIndex(entries, key);\n\n            if (~index) {\n                entries.splice(index, 1);\n            }\n        };\n\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.has = function (key) {\n            return !!~getIndex(this.__entries__, key);\n        };\n\n        /**\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.clear = function () {\n            this.__entries__.splice(0);\n        };\n\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\n        anonymous.prototype.forEach = function (callback, ctx) {\n            var this$1 = this;\n            if ( ctx === void 0 ) ctx = null;\n\n            for (var i = 0, list = this$1.__entries__; i < list.length; i += 1) {\n                var entry = list[i];\n\n                callback.call(ctx, entry[1], entry[0]);\n            }\n        };\n\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\n\n        return anonymous;\n    }());\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\nvar global$1 = (function () {\n    if (typeof global !== 'undefined' && global.Math === Math) {\n        return global;\n    }\n\n    if (typeof self !== 'undefined' && self.Math === Math) {\n        return self;\n    }\n\n    if (typeof window !== 'undefined' && window.Math === Math) {\n        return window;\n    }\n\n    // eslint-disable-next-line no-new-func\n    return Function('return this')();\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\nvar requestAnimationFrame$1 = (function () {\n    if (typeof requestAnimationFrame === 'function') {\n        // It's required to use a bounded function because IE sometimes throws\n        // an \"Invalid calling object\" error if rAF is invoked without the global\n        // object on the left hand side.\n        return requestAnimationFrame.bind(global$1);\n    }\n\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\n})();\n\n// Defines minimum timeout before adding a trailing call.\nvar trailingTimeout = 2;\n\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\nvar throttle = function (callback, delay) {\n    var leadingCall = false,\n        trailingCall = false,\n        lastCallTime = 0;\n\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\n    function resolvePending() {\n        if (leadingCall) {\n            leadingCall = false;\n\n            callback();\n        }\n\n        if (trailingCall) {\n            proxy();\n        }\n    }\n\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\n    function timeoutCallback() {\n        requestAnimationFrame$1(resolvePending);\n    }\n\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\n    function proxy() {\n        var timeStamp = Date.now();\n\n        if (leadingCall) {\n            // Reject immediately following calls.\n            if (timeStamp - lastCallTime < trailingTimeout) {\n                return;\n            }\n\n            // Schedule new call to be in invoked when the pending one is resolved.\n            // This is important for \"transitions\" which never actually start\n            // immediately so there is a chance that we might miss one if change\n            // happens amids the pending invocation.\n            trailingCall = true;\n        } else {\n            leadingCall = true;\n            trailingCall = false;\n\n            setTimeout(timeoutCallback, delay);\n        }\n\n        lastCallTime = timeStamp;\n    }\n\n    return proxy;\n};\n\n// Minimum delay before invoking the update of observers.\nvar REFRESH_DELAY = 20;\n\n// A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\n\n// Check if MutationObserver is available.\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\n\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\nvar ResizeObserverController = function() {\n    this.connected_ = false;\n    this.mutationEventsAdded_ = false;\n    this.mutationsObserver_ = null;\n    this.observers_ = [];\n\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n};\n\n/**\r\n * Adds observer to observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be added.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Holds reference to the controller's instance.\r\n *\r\n * @private {ResizeObserverController}\r\n */\n\n\n/**\r\n * Keeps reference to the instance of MutationObserver.\r\n *\r\n * @private {MutationObserver}\r\n */\n\n/**\r\n * Indicates whether DOM listeners have been added.\r\n *\r\n * @private {boolean}\r\n */\nResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n        this.observers_.push(observer);\n    }\n\n    // Add listeners if they haven't been added yet.\n    if (!this.connected_) {\n        this.connect_();\n    }\n};\n\n/**\r\n * Removes observer from observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer);\n\n    // Remove observer if it's present in registry.\n    if (~index) {\n        observers.splice(index, 1);\n    }\n\n    // Remove listeners if controller has no connected observers.\n    if (!observers.length && this.connected_) {\n        this.disconnect_();\n    }\n};\n\n/**\r\n * Invokes the update of observers. It will continue running updates insofar\r\n * it detects changes.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_();\n\n    // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n    if (changesDetected) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Updates every observer from observers list and notifies them of queued\r\n * entries.\r\n *\r\n * @private\r\n * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n *  dimensions of it's elements.\r\n */\nResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n        return observer.gatherActive(), observer.hasActive();\n    });\n\n    // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\n\n    return activeObservers.length > 0;\n};\n\n/**\r\n * Initializes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n        return;\n    }\n\n    // Subscription to the \"Transitionend\" event is used as a workaround for\n    // delayed transitions. This way it's possible to capture at least the\n    // final state of an element.\n    document.addEventListener('transitionend', this.onTransitionEnd_);\n\n    window.addEventListener('resize', this.refresh);\n\n    if (mutationObserverSupported) {\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\n\n        this.mutationsObserver_.observe(document, {\n            attributes: true,\n            childList: true,\n            characterData: true,\n            subtree: true\n        });\n    } else {\n        document.addEventListener('DOMSubtreeModified', this.refresh);\n\n        this.mutationEventsAdded_ = true;\n    }\n\n    this.connected_ = true;\n};\n\n/**\r\n * Removes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n        return;\n    }\n\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\n    window.removeEventListener('resize', this.refresh);\n\n    if (this.mutationsObserver_) {\n        this.mutationsObserver_.disconnect();\n    }\n\n    if (this.mutationEventsAdded_) {\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\n    }\n\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n};\n\n/**\r\n * \"Transitionend\" event handler.\r\n *\r\n * @private\r\n * @param {TransitionEvent} event\r\n * @returns {void}\r\n */\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\n        var propertyName = ref.propertyName; if ( propertyName === void 0 ) propertyName = '';\n\n    // Detect whether transition may affect dimensions of an element.\n    var isReflowProperty = transitionKeys.some(function (key) {\n        return !!~propertyName.indexOf(key);\n    });\n\n    if (isReflowProperty) {\n        this.refresh();\n    }\n};\n\n/**\r\n * Returns instance of the ResizeObserverController.\r\n *\r\n * @returns {ResizeObserverController}\r\n */\nResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n        this.instance_ = new ResizeObserverController();\n    }\n\n    return this.instance_;\n};\n\nResizeObserverController.instance_ = null;\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\nvar defineConfigurable = (function (target, props) {\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\n        var key = list[i];\n\n        Object.defineProperty(target, key, {\n            value: props[key],\n            enumerable: false,\n            writable: false,\n            configurable: true\n        });\n    }\n\n    return target;\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\nvar getWindowOf = (function (target) {\n    // Assume that the element is an instance of Node, which means that it\n    // has the \"ownerDocument\" property from which we can retrieve a\n    // corresponding global object.\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\n\n    // Return the local global object if it's not possible extract one from\n    // provided element.\n    return ownerGlobal || global$1;\n});\n\n// Placeholder of an empty content rectangle.\nvar emptyRect = createRectInit(0, 0, 0, 0);\n\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\nfunction getBordersSize(styles) {\n    var positions = [], len = arguments.length - 1;\n    while ( len-- > 0 ) positions[ len ] = arguments[ len + 1 ];\n\n    return positions.reduce(function (size, position) {\n        var value = styles['border-' + position + '-width'];\n\n        return size + toFloat(value);\n    }, 0);\n}\n\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\nfunction getPaddings(styles) {\n    var positions = ['top', 'right', 'bottom', 'left'];\n    var paddings = {};\n\n    for (var i = 0, list = positions; i < list.length; i += 1) {\n        var position = list[i];\n\n        var value = styles['padding-' + position];\n\n        paddings[position] = toFloat(value);\n    }\n\n    return paddings;\n}\n\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getSVGContentRect(target) {\n    var bbox = target.getBBox();\n\n    return createRectInit(0, 0, bbox.width, bbox.height);\n}\n\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\nfunction getHTMLElementContentRect(target) {\n    // Client width & height properties can't be\n    // used exclusively as they provide rounded values.\n    var clientWidth = target.clientWidth;\n    var clientHeight = target.clientHeight;\n\n    // By this condition we can catch all non-replaced inline, hidden and\n    // detached elements. Though elements with width & height properties less\n    // than 0.5 will be discarded as well.\n    //\n    // Without it we would need to implement separate methods for each of\n    // those cases and it's not possible to perform a precise and performance\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n    // gives wrong results for elements with width & height less than 0.5.\n    if (!clientWidth && !clientHeight) {\n        return emptyRect;\n    }\n\n    var styles = getWindowOf(target).getComputedStyle(target);\n    var paddings = getPaddings(styles);\n    var horizPad = paddings.left + paddings.right;\n    var vertPad = paddings.top + paddings.bottom;\n\n    // Computed styles of width & height are being used because they are the\n    // only dimensions available to JS that contain non-rounded values. It could\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\n    var width = toFloat(styles.width),\n        height = toFloat(styles.height);\n\n    // Width & height include paddings and borders when the 'border-box' box\n    // model is applied (except for IE).\n    if (styles.boxSizing === 'border-box') {\n        // Following conditions are required to handle Internet Explorer which\n        // doesn't include paddings and borders to computed CSS dimensions.\n        //\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\n        // properties then it's either IE, and thus we don't need to subtract\n        // anything, or an element merely doesn't have paddings/borders styles.\n        if (Math.round(width + horizPad) !== clientWidth) {\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\n        }\n\n        if (Math.round(height + vertPad) !== clientHeight) {\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n        }\n    }\n\n    // Following steps can't be applied to the document's root element as its\n    // client[Width/Height] properties represent viewport area of the window.\n    // Besides, it's as well not necessary as the <html> itself neither has\n    // rendered scroll bars nor it can be clipped.\n    if (!isDocumentElement(target)) {\n        // In some browsers (only in Firefox, actually) CSS width & height\n        // include scroll bars size which can be removed at this step as scroll\n        // bars are the only difference between rounded dimensions + paddings\n        // and \"client\" properties, though that is not always true in Chrome.\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\n\n        // Chrome has a rather weird rounding of \"client\" properties.\n        // E.g. for an element with content width of 314.2px it sometimes gives\n        // the client width of 315px and for the width of 314.7px it may give\n        // 314px. And it doesn't happen all the time. So just ignore this delta\n        // as a non-relevant.\n        if (Math.abs(vertScrollbar) !== 1) {\n            width -= vertScrollbar;\n        }\n\n        if (Math.abs(horizScrollbar) !== 1) {\n            height -= horizScrollbar;\n        }\n    }\n\n    return createRectInit(paddings.left, paddings.top, width, height);\n}\n\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nvar isSVGGraphicsElement = (function () {\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n    // interface.\n    if (typeof SVGGraphicsElement !== 'undefined') {\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\n    }\n\n    // If it's so, then check that element is at least an instance of the\n    // SVGElement and that it has the \"getBBox\" method.\n    // eslint-disable-next-line no-extra-parens\n    return function (target) { return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function'; };\n})();\n\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\nfunction isDocumentElement(target) {\n    return target === getWindowOf(target).document.documentElement;\n}\n\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\nfunction getContentRect(target) {\n    if (!isBrowser) {\n        return emptyRect;\n    }\n\n    if (isSVGGraphicsElement(target)) {\n        return getSVGContentRect(target);\n    }\n\n    return getHTMLElementContentRect(target);\n}\n\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\nfunction createReadOnlyRect(ref) {\n    var x = ref.x;\n    var y = ref.y;\n    var width = ref.width;\n    var height = ref.height;\n\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n    var rect = Object.create(Constr.prototype);\n\n    // Rectangle's properties are not writable and non-enumerable.\n    defineConfigurable(rect, {\n        x: x, y: y, width: width, height: height,\n        top: y,\n        right: x + width,\n        bottom: height + y,\n        left: x\n    });\n\n    return rect;\n}\n\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\nfunction createRectInit(x, y, width, height) {\n    return { x: x, y: y, width: width, height: height };\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\nvar ResizeObservation = function(target) {\n    this.broadcastWidth = 0;\n    this.broadcastHeight = 0;\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n\n    this.target = target;\n};\n\n/**\r\n * Updates content rectangle and tells whether it's width or height properties\r\n * have changed since the last broadcast.\r\n *\r\n * @returns {boolean}\r\n */\n\n\n/**\r\n * Reference to the last observed content rectangle.\r\n *\r\n * @private {DOMRectInit}\r\n */\n\n\n/**\r\n * Broadcasted width of content rectangle.\r\n *\r\n * @type {number}\r\n */\nResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n\n    this.contentRect_ = rect;\n\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n};\n\n/**\r\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n * from the corresponding properties of the last observed content rectangle.\r\n *\r\n * @returns {DOMRectInit} Last observed content rectangle.\r\n */\nResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n\n    return rect;\n};\n\nvar ResizeObserverEntry = function(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit);\n\n    // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they'd require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don't support this type of collections.\n    defineConfigurable(this, { target: target, contentRect: contentRect });\n};\n\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\n    this.activeObservations_ = [];\n    this.observations_ = new MapShim();\n\n    if (typeof callback !== 'function') {\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\n    }\n\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n};\n\n/**\r\n * Starts observing provided element.\r\n *\r\n * @param {Element} target - Element to be observed.\r\n * @returns {void}\r\n */\n\n\n/**\r\n * Registry of the ResizeObservation instances.\r\n *\r\n * @private {Map<Element, ResizeObservation>}\r\n */\n\n\n/**\r\n * Public ResizeObserver instance which will be passed to the callback\r\n * function and used as a value of it's \"this\" binding.\r\n *\r\n * @private {ResizeObserver}\r\n */\n\n/**\r\n * Collection of resize observations that have detected changes in dimensions\r\n * of elements.\r\n *\r\n * @private {Array<ResizeObservation>}\r\n */\nResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is already being observed.\n    if (observations.has(target)) {\n        return;\n    }\n\n    observations.set(target, new ResizeObservation(target));\n\n    this.controller_.addObserver(this);\n\n    // Force the update of observations.\n    this.controller_.refresh();\n};\n\n/**\r\n * Stops observing provided element.\r\n *\r\n * @param {Element} target - Element to stop observing.\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    // Do nothing if current environment doesn't have the Element interface.\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n        return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n        throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_;\n\n    // Do nothing if element is not being observed.\n    if (!observations.has(target)) {\n        return;\n    }\n\n    observations.delete(target);\n\n    if (!observations.size) {\n        this.controller_.removeObserver(this);\n    }\n};\n\n/**\r\n * Stops observing all elements.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n};\n\n/**\r\n * Collects observation instances the associated element of which has changed\r\n * it's content rectangle.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.gatherActive = function () {\n        var this$1 = this;\n\n    this.clearActive();\n\n    this.observations_.forEach(function (observation) {\n        if (observation.isActive()) {\n            this$1.activeObservations_.push(observation);\n        }\n    });\n};\n\n/**\r\n * Invokes initial callback function with a list of ResizeObserverEntry\r\n * instances collected from active resize observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn't have active observations.\n    if (!this.hasActive()) {\n        return;\n    }\n\n    var ctx = this.callbackCtx_;\n\n    // Create ResizeObserverEntry instance for every active observation.\n    var entries = this.activeObservations_.map(function (observation) {\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n};\n\n/**\r\n * Clears the collection of active observations.\r\n *\r\n * @returns {void}\r\n */\nResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n};\n\n/**\r\n * Tells whether observer has active observations.\r\n *\r\n * @returns {boolean}\r\n */\nResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n};\n\n// Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\nvar ResizeObserver = function(callback) {\n    if (!(this instanceof ResizeObserver)) {\n        throw new TypeError('Cannot call a class as a function.');\n    }\n    if (!arguments.length) {\n        throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n\n    observers.set(this, observer);\n};\n\n// Expose public methods of ResizeObserver.\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n    ResizeObserver.prototype[method] = function () {\n        return (ref = observers.get(this))[method].apply(ref, arguments);\n        var ref;\n    };\n});\n\nvar index = (function () {\n    // Export existing implementation if available.\n    if (typeof global$1.ResizeObserver !== 'undefined') {\n        return global$1.ResizeObserver;\n    }\n\n    return ResizeObserver;\n})();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://gridcanvas/./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack://gridcanvas/./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack://gridcanvas/./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://gridcanvas/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/Config.ts":
/*!***********************!*\
  !*** ./src/Config.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n;\nexports.defaultConfig = {\n    gridSeries: [[10, 2], [50, 10], [100, 10], [200, 20]],\n    bound: { minX: -500, maxX: 1500, minY: -500, maxY: 1500 },\n    majorGridDensity: 0.02,\n    aspeckLocked: true,\n    showGrid: true\n};\n\n\n//# sourceURL=webpack://gridcanvas/./src/Config.ts?");

/***/ }),

/***/ "./src/GridCanvas.ts":
/*!***************************!*\
  !*** ./src/GridCanvas.ts ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Config_1 = __webpack_require__(/*! ./Config */ \"./src/Config.ts\");\nvar UiController_1 = __importDefault(__webpack_require__(/*! ./UiController */ \"./src/UiController.ts\"));\nvar resize_observer_polyfill_1 = __importDefault(__webpack_require__(/*! resize-observer-polyfill */ \"./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\"));\nvar GridCanvas = (function () {\n    function GridCanvas(elementID, config) {\n        var _this = this;\n        this.redrawUpper = function () { };\n        this.redrawLower = function () { };\n        this.majorGridColor = '#cccccc';\n        this.majorGridWidth = 0.5;\n        this.minorGridColor = '#dddddd';\n        this.minorGridWidth = 0.4;\n        this.aspectLock = true;\n        this.showGridsFlag = true;\n        this.display = function () {\n            var _a = [\n                _this.displayRect.minX,\n                _this.displayRect.maxX,\n                _this.displayRect.minY,\n                _this.displayRect.maxY\n            ], minX = _a[0], maxX = _a[1], minY = _a[2], maxY = _a[3];\n            _this.redrawLower(_this.lowerLayer.getContext('2d'));\n            _this.drawGridLines();\n            _this.redrawUpper(_this.upperLayer.getContext('2d'));\n        };\n        this.v2pX = function (viewX) {\n            return viewX / _this.gridLayer.width * (_this.displayRect.maxX - _this.displayRect.minX) + _this.displayRect.minX;\n        };\n        this.v2pY = function (viewY) {\n            return _this.displayRect.maxY - viewY / _this.gridLayer.height * (_this.displayRect.maxY - _this.displayRect.minY);\n        };\n        this.p2vX = function (projectX) {\n            return (projectX - _this.displayRect.minX) / (_this.displayRect.maxX - _this.displayRect.minX) * _this.gridLayer.width;\n        };\n        this.p2vY = function (projectY) {\n            return (_this.displayRect.maxY - projectY) / (_this.displayRect.maxY - _this.displayRect.minY) * _this.gridLayer.height;\n        };\n        var bound = (config ? config.bound : undefined) || Config_1.defaultConfig.bound;\n        this.gridSeries = (config ? config.gridSeries : undefined) || Config_1.defaultConfig.gridSeries;\n        this.majorGridDensity = (config ? config.majorGridDensity : undefined) || Config_1.defaultConfig.majorGridDensity;\n        this.aspectLock = (config ? config.aspeckLocked : undefined) || Config_1.defaultConfig.aspeckLocked;\n        this.showGridsFlag = (config ? config.showGrid : undefined) || Config_1.defaultConfig.showGrid;\n        var container = document.getElementById(elementID);\n        this.container = container;\n        this.container.style.textAlign = 'left';\n        this.container.style.position = 'relative';\n        this.lowerLayer = document.createElement('canvas');\n        this.lowerLayer.style.position = 'absolute';\n        this.lowerLayer.id = (this.container.id || 'preview-container') + '-upper';\n        this.lowerLayer.style.width = '100%';\n        this.lowerLayer.style.height = '100%';\n        this.container.appendChild(this.lowerLayer);\n        this.lowerLayer.width = this.lowerLayer.clientWidth;\n        this.lowerLayer.height = this.lowerLayer.clientHeight;\n        this.gridLayer = document.createElement('canvas');\n        this.gridLayer.style.position = 'absolute';\n        this.gridLayer.id = (this.container.id || 'preview-container') + '-canvas';\n        this.gridLayer.style.width = '100%';\n        this.gridLayer.style.height = '100%';\n        this.container.appendChild(this.gridLayer);\n        this.gridLayer.width = this.gridLayer.clientWidth;\n        this.gridLayer.height = this.gridLayer.clientHeight;\n        this.upperLayer = document.createElement('canvas');\n        this.upperLayer.style.position = 'absolute';\n        this.upperLayer.id = (this.container.id || 'preview-container') + '-upper';\n        this.upperLayer.style.width = '100%';\n        this.upperLayer.style.height = '100%';\n        this.container.appendChild(this.upperLayer);\n        this.upperLayer.width = this.upperLayer.clientWidth;\n        this.upperLayer.height = this.upperLayer.clientHeight;\n        var resizeCallback = function () {\n            var _a = [_this.gridLayer.width, _this.gridLayer.height], oldWidth = _a[0], oldHeight = _a[1];\n            var newWidth = _this.upperLayer.width = _this.lowerLayer.width = _this.gridLayer.width = _this.container.clientWidth;\n            var newHeight = _this.upperLayer.height = _this.lowerLayer.height = _this.gridLayer.height = _this.container.clientHeight;\n            if (newWidth > newHeight / oldHeight * oldWidth) {\n                var midY = (_this.displayRect.minY + _this.displayRect.maxY) / 2;\n                var newDisplayHeight = (_this.displayRect.maxX - _this.displayRect.minX) / newWidth * newHeight;\n                _this.displayRect.minY = midY - newDisplayHeight / 2;\n                _this.displayRect.maxY = midY + newDisplayHeight / 2;\n            }\n            else {\n                var midX = (_this.displayRect.minX + _this.displayRect.maxX) / 2;\n                var newDisplayWidth = (_this.displayRect.maxY - _this.displayRect.minY) / newHeight * newWidth;\n                _this.displayRect.minX = midX - newDisplayWidth / 2;\n                _this.displayRect.maxX = midX + newDisplayWidth / 2;\n            }\n            _this.uiOverlay.updateDifferences();\n            _this.uiOverlay.syncView();\n            _this.display();\n        };\n        var ro = new resize_observer_polyfill_1.default(resizeCallback);\n        ro.observe(this.gridLayer);\n        var parent = this;\n        this.displayRect = {\n            _minx: bound.minX, _maxx: bound.maxX, _maxy: bound.maxY,\n            _miny: bound.maxY - (bound.maxX - bound.minX) / this.gridLayer.width * this.gridLayer.height,\n            get minX() { return this._minx; },\n            get maxX() { return this._maxx; },\n            get minY() { return this._miny; },\n            get maxY() { return this._maxy; },\n            set minX(newVal) {\n                this.setMinX(newVal);\n                if (parent.uiOverlay) {\n                    parent.uiOverlay.syncView();\n                }\n                parent.display();\n            },\n            set maxX(newVal) {\n                this.setMaxX(newVal);\n                if (parent.uiOverlay) {\n                    parent.uiOverlay.syncView();\n                }\n                parent.display();\n            },\n            set minY(newVal) {\n                this.setMinY(newVal);\n                if (parent.uiOverlay) {\n                    parent.uiOverlay.syncView();\n                }\n                parent.display();\n            },\n            set maxY(newVal) {\n                this.setMaxY(newVal);\n                if (parent.uiOverlay) {\n                    parent.uiOverlay.syncView();\n                }\n                parent.display();\n            },\n            setMinX: function (newVal) { this._minx = newVal; },\n            setMaxX: function (newVal) { this._maxx = newVal; },\n            setMinY: function (newVal) { this._miny = newVal; },\n            setMaxY: function (newVal) { this._maxy = newVal; }\n        };\n        if ((bound.maxX - bound.minX) / (bound.maxY - bound.minY) > this.gridLayer.width / this.gridLayer.height) {\n            this.displayRect._maxy = bound.maxY;\n            this.displayRect._minx = bound.maxX - (bound.maxY - bound.minY) / this.gridLayer.height * this.gridLayer.width;\n        }\n        this.bound = {\n            _minx: bound.minX, _maxx: bound.maxX, _miny: bound.minY, _maxy: bound.maxY,\n            get minX() { return this._minx; },\n            get maxX() { return this._maxx; },\n            get minY() { return this._miny; },\n            get maxY() { return this._maxy; },\n            set minX(newVal) {\n                if (parent.uiOverlay) {\n                    parent.uiOverlay.syncView();\n                }\n                this.setMinX(newVal);\n                parent.display();\n            },\n            set maxX(newVal) {\n                if (parent.uiOverlay) {\n                    parent.uiOverlay.syncView();\n                }\n                this.setMaxX(newVal);\n                parent.display();\n            },\n            set minY(newVal) {\n                if (parent.uiOverlay) {\n                    parent.uiOverlay.syncView();\n                }\n                this.setMinY(newVal);\n                parent.display();\n            },\n            set maxY(newVal) {\n                if (parent.uiOverlay) {\n                    parent.uiOverlay.syncView();\n                }\n                this.setMaxY(newVal);\n                parent.display();\n            },\n            setMinX: function (newVal) { this._minx = newVal; },\n            setMaxX: function (newVal) { this._maxx = newVal; },\n            setMinY: function (newVal) { this._miny = newVal; },\n            setMaxY: function (newVal) { this._maxy = newVal; }\n        };\n        this.uiOverlay = new UiController_1.default(this);\n        this.display();\n    }\n    Object.defineProperty(GridCanvas.prototype, \"zoomFactor\", {\n        get: function () { return (this.displayRect.maxX - this.displayRect.minX) / (this.bound.maxX - this.bound.minX); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GridCanvas.prototype, \"aspectLocked\", {\n        get: function () { return this.aspectLock; },\n        set: function (newVal) { this.aspectLock = newVal; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GridCanvas.prototype, \"showGrids\", {\n        get: function () { return this.showGridsFlag; },\n        set: function (newVal) { this.showGridsFlag = newVal; this.display(); },\n        enumerable: true,\n        configurable: true\n    });\n    GridCanvas.prototype.zoomDisplay = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var x, y;\n        x = args[0];\n        y = args[1];\n        var scale = args.pop();\n        if (scale === 1)\n            return;\n        if (scale > 1 && (this.displayRect.minX === this.bound.minX && this.displayRect.maxX === this.bound.maxX\n            || this.displayRect.minY === this.bound.minY && this.displayRect.maxY === this.bound.maxY))\n            return;\n        if (scale < 1 && this.uiOverlay.horizontalBar.upperRange - this.uiOverlay.horizontalBar.lowerRange < this.uiOverlay.horizontalBar.minDifference)\n            return;\n        if (scale < 1 && this.uiOverlay.verticalBar.upperRange - this.uiOverlay.verticalBar.lowerRange < this.uiOverlay.verticalBar.minDifference)\n            return;\n        var offsets = {\n            minX: this.displayRect.minX - x,\n            maxX: this.displayRect.maxX - x,\n            minY: this.displayRect.minY - y,\n            maxY: this.displayRect.maxY - y\n        };\n        offsets.minX *= scale;\n        offsets.maxX *= scale;\n        offsets.minY *= scale;\n        offsets.maxY *= scale;\n        var expected = {\n            minX: offsets.minX + x,\n            maxX: offsets.maxX + x,\n            minY: offsets.minY + y,\n            maxY: offsets.maxY + y\n        };\n        if (expected.minY < this.bound.minY) {\n            var d = this.bound.minY - expected.minY;\n            expected.minY = this.bound.minY;\n            expected.maxY += d;\n            if (expected.maxY > this.bound.maxY) {\n                expected.maxY = this.bound.maxX;\n                var expectedDx = (this.bound.maxY - this.bound.minY) / this.gridLayer.height * this.gridLayer.width;\n                var diff = expectedDx - (expected.maxX - expected.minX);\n                expected.maxX += diff / 2;\n                expected.minX -= diff / 2;\n            }\n        }\n        if (expected.maxY > this.bound.maxY) {\n            var d = expected.maxY - this.bound.maxY;\n            expected.maxY = this.bound.maxY;\n            expected.minY -= d;\n            if (expected.minY < this.bound.minY) {\n                expected.minY = this.bound.minY;\n                var expectedDx = (this.bound.maxY - this.bound.minY) / this.gridLayer.height * this.gridLayer.width;\n                var diff = expectedDx - (expected.maxX - expected.minX);\n                expected.minX += diff / 2;\n                expected.minX -= diff / 2;\n            }\n        }\n        if (expected.minX < this.bound.minX) {\n            var d = this.bound.minX - expected.minX;\n            expected.minX = this.bound.minX;\n            expected.maxX += d;\n            if (expected.maxX > this.bound.maxX) {\n                expected.maxX = this.bound.maxX;\n                var expectedDy = (this.bound.maxX - this.bound.minX) / this.gridLayer.width * this.gridLayer.height;\n                var diff = expectedDy - (expected.maxY - expected.minY);\n                expected.maxY += diff / 2;\n                expected.minY -= diff / 2;\n            }\n        }\n        if (expected.maxX > this.bound.maxX) {\n            var d = expected.maxX - this.bound.maxX;\n            expected.maxX = this.bound.maxX;\n            expected.minX -= d;\n            if (expected.minX < this.bound.minX) {\n                expected.minX = this.bound.minX;\n                var expectedDy = (this.bound.maxX - this.bound.minX) / this.gridLayer.width * this.gridLayer.height;\n                var diff = expectedDy - (expected.maxY - expected.minY);\n                expected.maxY += diff / 2;\n                expected.minY -= diff / 2;\n            }\n        }\n        this.displayRect.minX = expected.minX;\n        this.displayRect.maxX = expected.maxX;\n        this.displayRect.minY = expected.minY;\n        this.displayRect.maxY = expected.maxY;\n        this.uiOverlay.syncView();\n        this.display();\n    };\n    GridCanvas.prototype.scrollHorizontally = function (offset) {\n        if (this.displayRect.minX + offset < this.bound.minX)\n            offset = this.bound.minX - this.displayRect.minX;\n        if (this.displayRect.maxX + offset > this.bound.maxX)\n            offset = this.bound.maxX - this.displayRect.maxX;\n        this.displayRect.minX += offset;\n        this.displayRect.maxX += offset;\n        this.uiOverlay.syncView();\n        this.display();\n    };\n    GridCanvas.prototype.scrollVertically = function (offset) {\n        if (this.displayRect.minY + offset < this.bound.minY)\n            offset = this.bound.minY - this.displayRect.minY;\n        if (this.displayRect.maxY + offset > this.bound.maxY)\n            offset = this.bound.maxY - this.displayRect.maxY;\n        this.displayRect.minY += offset;\n        this.displayRect.maxY += offset;\n        this.uiOverlay.syncView();\n        this.display();\n    };\n    GridCanvas.prototype.drawGridLines = function () {\n        var _this = this;\n        var ctx = this.gridLayer.getContext('2d');\n        ctx.clearRect(0, 0, this.gridLayer.width, this.gridLayer.height);\n        if (!this.showGridsFlag)\n            return;\n        var nMaxHorizontal = Math.ceil(this.majorGridDensity * this.gridLayer.height);\n        var nMaxVertical = Math.ceil(this.majorGridDensity * this.gridLayer.width);\n        var checkGridUseability = function (a) {\n            var max = Math.max.apply(_this, a);\n            if (max * nMaxHorizontal > _this.displayRect.maxY - _this.displayRect.minY\n                && max * nMaxVertical > _this.displayRect.maxX - _this.displayRect.minX)\n                return true;\n            else\n                return false;\n        };\n        var nHMajorGridLines = 0, nVMajorGridLines = 0;\n        var nHMinorGridLines = 0, nVMinorGridLines = 0;\n        var useableGrid = [0, 0];\n        for (var i in this.gridSeries) {\n            var max = Math.max.apply(this, this.gridSeries[i]);\n            var min = Math.min.apply(this, this.gridSeries[i]);\n            if (checkGridUseability(this.gridSeries[i])) {\n                useableGrid = this.gridSeries[i];\n                nHMajorGridLines = Math.ceil((this.displayRect.maxY - this.displayRect.minY) / max);\n                nVMajorGridLines = Math.ceil((this.displayRect.maxX - this.displayRect.minX) / max);\n                nHMinorGridLines = Math.ceil((this.displayRect.maxY - this.displayRect.minY) / min);\n                nVMinorGridLines = Math.ceil((this.displayRect.maxX - this.displayRect.minX) / min);\n                break;\n            }\n        }\n        var _a = [this.gridLayer.width, this.gridLayer.height], w = _a[0], h = _a[1];\n        var minProjectDiff = Math.min.apply(this, useableGrid);\n        var minViewDiff = Math.min.apply(this, useableGrid) / (this.displayRect.maxX - this.displayRect.minX) * this.gridLayer.width;\n        var firstMinorHLineY = this.p2vY(Math.ceil(this.displayRect.minY / minProjectDiff) * minProjectDiff);\n        ctx.fillStyle = this.minorGridColor;\n        for (var i = 0; i < nHMinorGridLines; i++) {\n            ctx.fillRect(0, firstMinorHLineY - i * minViewDiff - this.minorGridWidth / 2, w, this.minorGridWidth);\n        }\n        var firstMinorVLineX = this.p2vX(Math.ceil(this.displayRect.minX / minProjectDiff) * minProjectDiff);\n        for (var i = 0; i < nVMinorGridLines; i++) {\n            ctx.fillRect(firstMinorVLineX + i * minViewDiff - this.minorGridWidth / 2, 0, this.minorGridWidth, h);\n        }\n        var maxProjectDiff = Math.max.apply(this, useableGrid);\n        var maxViewDiff = Math.max.apply(this, useableGrid) / (this.displayRect.maxX - this.displayRect.minX) * this.gridLayer.width;\n        var firstMajorHLineY = this.p2vY(Math.ceil(this.displayRect.minY / maxProjectDiff) * maxProjectDiff);\n        ctx.fillStyle = this.majorGridColor;\n        for (var i = 0; i < nHMajorGridLines; i++) {\n            ctx.fillRect(0, firstMajorHLineY - i * maxViewDiff - this.majorGridWidth / 2, w, this.majorGridWidth);\n        }\n        var firstMajorVLineX = this.p2vX(Math.ceil(this.displayRect.minX / maxProjectDiff) * maxProjectDiff);\n        for (var i = 0; i < nVMajorGridLines; i++) {\n            ctx.fillRect(firstMajorVLineX + i * maxViewDiff - this.majorGridWidth / 2, 0, this.majorGridWidth, h);\n        }\n    };\n    GridCanvas.prototype.projectToView = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var x, y;\n        if (typeof args[0] === 'number') {\n            x = args[0];\n            y = args[1];\n        }\n        else if (args[0]) {\n            var arg = args[0];\n            if (arg.length !== 2) {\n                throw Error(\"Invalid parameter \" + arg);\n            }\n            x = arg[0];\n            y = arg[1];\n        }\n        return [this.p2vX(x), this.p2vY(y)];\n    };\n    GridCanvas.prototype.viewToProject = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var x, y;\n        if (typeof args[0] === 'number') {\n            x = args[0];\n            y = args[1];\n        }\n        else if (args[0]) {\n            var arg = args[0];\n            if (arg.length !== 2) {\n                throw Error(\"Invalid parameter \" + arg);\n            }\n            x = arg[0];\n            y = arg[1];\n        }\n        return [this.v2pX(x), this.v2pY(y)];\n    };\n    GridCanvas.prototype.destruct = function () {\n        this.container.removeChild(this.uiOverlay.container);\n        this.container.removeChild(this.gridLayer);\n        this.container.removeChild(this.upperLayer);\n        this.container.removeChild(this.lowerLayer);\n    };\n    return GridCanvas;\n}());\nexports.default = GridCanvas;\n;\n\n\n//# sourceURL=webpack://gridcanvas/./src/GridCanvas.ts?");

/***/ }),

/***/ "./src/UiController.ts":
/*!*****************************!*\
  !*** ./src/UiController.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar dual = __importStar(__webpack_require__(/*! dual-range-bar */ \"./node_modules/dual-range-bar/dist/dual-range-bar.min.js\"));\n__webpack_require__(/*! ./style.css */ \"./src/style.css\");\nvar UIOverlay = (function () {\n    function UIOverlay(gridCanvas) {\n        var _this = this;\n        this.ctrlDownFlag = false;\n        this.altDownFlag = false;\n        this.shiftDownFlag = false;\n        this.mouseOver = false;\n        this.gridCanvas = gridCanvas;\n        this.container = document.createElement('div');\n        this.container.style.position = 'relative';\n        this.container.style.width = '100%';\n        this.container.style.height = '100%';\n        gridCanvas.container.appendChild(this.container);\n        var hbarContainer = document.createElement('div');\n        hbarContainer.className = 'hbar-container';\n        hbarContainer.style.height = '20px';\n        hbarContainer.style.width = 'calc(100% - 125px)';\n        hbarContainer.style.margin = '20px 40px';\n        hbarContainer.style.position = 'absolute';\n        hbarContainer.style.bottom = '0px';\n        hbarContainer.style.zIndex = '1';\n        var hbar = document.createElement('div');\n        hbar.id = \"horizontal-scrolling-bar-\" + new Date().getTime();\n        hbar.style.height = '100%';\n        hbar.style.width = '100%';\n        hbar.style.position = 'relative';\n        hbarContainer.appendChild(hbar);\n        this.container.appendChild(hbarContainer);\n        this.horizontalBar = dual.HRange.getObject(hbar.id);\n        this.horizontalBar.lowerBound = 0;\n        this.horizontalBar.upperBound = 1;\n        var vbarContainer = document.createElement('div');\n        vbarContainer.className = 'vbar-container';\n        vbarContainer.style.height = 'calc(100% - 120px)';\n        vbarContainer.style.width = '20px';\n        vbarContainer.style.margin = '40px 20px';\n        vbarContainer.style.position = 'absolute';\n        vbarContainer.style.right = '0px';\n        vbarContainer.style.zIndex = '1';\n        var vbar = document.createElement('div');\n        vbar.id = \"vertical-scrolling-bar-\" + new Date().getTime();\n        vbar.style.height = '100%';\n        vbar.style.width = '100%';\n        vbar.style.position = 'relative';\n        vbarContainer.appendChild(vbar);\n        this.container.appendChild(vbarContainer);\n        this.verticalBar = dual.VRange.getObject(vbar.id);\n        this.verticalBar.lowerBound = 0;\n        this.verticalBar.upperBound = 1;\n        var buttonContainer = this.buttonContainer = document.createElement('div');\n        buttonContainer.className = 'button-container';\n        buttonContainer.style.width = '42px';\n        buttonContainer.style.height = '42px';\n        buttonContainer.style.position = 'absolute';\n        buttonContainer.style.right = '0px';\n        buttonContainer.style.bottom = '0px';\n        buttonContainer.style.margin = '16px';\n        buttonContainer.style.zIndex = '1';\n        var gridButton = this.gridButton = document.createElement('button');\n        gridButton.className = 'grid-button';\n        if (gridCanvas.showGrids) {\n            gridButton.classList.add('grid-on');\n        }\n        else {\n            gridButton.classList.add('grid-off');\n        }\n        gridButton.style.width = '42px';\n        gridButton.style.height = '42px';\n        gridButton.innerHTML = \"\\n  <svg version=\\\"1.1\\\" class=\\\"icon\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\"\\n  viewBox=\\\"0 0 100 100\\\" style=\\\"enable-background:new 0 0 100 100;\\\" xml:space=\\\"preserve\\\">\\n    <rect x=\\\"10\\\" y=\\\"10\\\" width=\\\"24\\\" height=\\\"24\\\"/>\\n    <rect x=\\\"40\\\" y=\\\"10\\\" width=\\\"24\\\" height=\\\"24\\\"/>\\n    <rect x=\\\"70\\\" y=\\\"10\\\" width=\\\"24\\\" height=\\\"24\\\"/>\\n    <rect x=\\\"10\\\" y=\\\"40\\\" width=\\\"24\\\" height=\\\"24\\\"/>\\n    <rect x=\\\"40\\\" y=\\\"40\\\" width=\\\"24\\\" height=\\\"24\\\"/>\\n    <rect x=\\\"70\\\" y=\\\"40\\\" width=\\\"24\\\" height=\\\"24\\\"/>\\n    <rect x=\\\"10\\\" y=\\\"70\\\" width=\\\"24\\\" height=\\\"24\\\"/>\\n    <rect x=\\\"40\\\" y=\\\"70\\\" width=\\\"24\\\" height=\\\"24\\\"/>\\n    <rect x=\\\"70\\\" y=\\\"70\\\" width=\\\"24\\\" height=\\\"24\\\"/>\\n  </svg>\";\n        gridButton.style.lineHeight = '120%';\n        gridButton.style.textAlign = 'center';\n        gridButton.addEventListener('click', function (event) {\n            gridCanvas.showGrids = !gridCanvas.showGrids;\n            if (gridCanvas.showGrids)\n                gridButton.classList.replace('grid-off', 'grid-on');\n            else\n                gridButton.classList.replace('grid-on', 'grid-off');\n        });\n        buttonContainer.appendChild(gridButton);\n        this.container.appendChild(buttonContainer);\n        this.updateDifferences();\n        this.horizontalBar.addLowerRangeChangeCallback(function (val) { _this.syncViewByHorizontal(); });\n        this.horizontalBar.addUpperRangeChangeCallback(function (val) { _this.syncViewByHorizontal(); });\n        this.verticalBar.addLowerRangeChangeCallback(function (val) { _this.syncViewByVertical(); });\n        this.verticalBar.addUpperRangeChangeCallback(function (val) { _this.syncViewByVertical(); });\n        var mac = false;\n        if (window.navigator.userAgent.search('Mac') > 0)\n            mac = true;\n        this.eventActiveArea = document.createElement('div');\n        this.eventActiveArea.style.position = 'relative';\n        this.eventActiveArea.style.width = '100%';\n        this.eventActiveArea.style.height = '100%';\n        this.eventActiveArea.style.zIndex = '0';\n        this.container.appendChild(this.eventActiveArea);\n        this.eventActiveArea.addEventListener('mouseover', function (event) { return _this.mouseOver = true; });\n        this.eventActiveArea.addEventListener('mouseout', function (event) { return _this.mouseOver = false; });\n        window.addEventListener('keydown', function (event) {\n            if (_this.mouseOver) {\n                if (event.key === 'Alt')\n                    _this.altDownFlag = true;\n                if (event.key === 'Shift')\n                    _this.shiftDownFlag = true;\n                if (mac) {\n                    if (event.key === 'Meta')\n                        _this.ctrlDownFlag = true;\n                }\n                else {\n                    if (event.key === 'Control')\n                        _this.ctrlDownFlag = true;\n                }\n            }\n            else {\n                _this.altDownFlag = false;\n                _this.shiftDownFlag = false;\n                _this.ctrlDownFlag = false;\n            }\n        });\n        window.addEventListener('keyup', function (event) {\n            if (_this.mouseOver) {\n                if (event.key === 'Alt')\n                    _this.altDownFlag = false;\n                if (event.key === 'Shift')\n                    _this.shiftDownFlag = false;\n                if (mac) {\n                    if (event.key === 'Meta')\n                        _this.ctrlDownFlag = false;\n                }\n                else {\n                    if (event.key === 'Control')\n                        _this.ctrlDownFlag = false;\n                }\n            }\n            else {\n                _this.altDownFlag = false;\n                _this.shiftDownFlag = false;\n                _this.ctrlDownFlag = false;\n            }\n        });\n        this.eventActiveArea.addEventListener('wheel', function (event) {\n            event.preventDefault();\n            var r = gridCanvas.zoomFactor;\n            if (_this.altDownFlag) {\n                var d = event.deltaY;\n                var _a = [event.offsetX, event.offsetY], x = _a[0], y = _a[1];\n                gridCanvas.zoomDisplay(gridCanvas.v2pX(x), gridCanvas.v2pY(y), Math.exp(d / 400));\n            }\n            else {\n                if (_this.shiftDownFlag) {\n                    var d = event.deltaY / r;\n                    if (d === 0)\n                        d = event.deltaX / r;\n                    gridCanvas.scrollHorizontally(d);\n                }\n                else {\n                    var d = -event.deltaY / r;\n                    gridCanvas.scrollVertically(d);\n                }\n            }\n        });\n    }\n    UIOverlay.prototype.updateDifferences = function () {\n        var gridCanvas = this.gridCanvas;\n        var rx = gridCanvas.gridLayer.width / (gridCanvas.bound.maxX - gridCanvas.bound.minX);\n        var ry = gridCanvas.gridLayer.height / (gridCanvas.bound.maxY - gridCanvas.bound.minY);\n        if (rx > ry) {\n            this.horizontalBar.relativeMinDifference = 0.1 * rx / ry;\n            this.horizontalBar.relativeMaxDifference = 1.0;\n            this.verticalBar.relativeMinDifference = 0.1;\n            this.verticalBar.relativeMaxDifference = 1.0 * ry / rx;\n        }\n        else {\n            this.horizontalBar.relativeMinDifference = 0.1;\n            this.horizontalBar.relativeMaxDifference = 1.0 * rx / ry;\n            this.verticalBar.relativeMinDifference = 0.1 * ry / rx;\n            this.verticalBar.relativeMaxDifference = 1.0;\n        }\n    };\n    UIOverlay.prototype.syncView = function () {\n        var gridCanvas = this.gridCanvas;\n        var boundWidth = gridCanvas.bound.maxX - gridCanvas.bound.minX;\n        var boundHeight = gridCanvas.bound.maxY - gridCanvas.bound.minY;\n        var minX = (gridCanvas.displayRect.minX - gridCanvas.bound.minX) / boundWidth;\n        var maxX = (gridCanvas.displayRect.maxX - gridCanvas.bound.minX) / boundWidth;\n        var minY = (gridCanvas.bound.maxY - gridCanvas.displayRect.maxY) / boundHeight;\n        var maxY = (gridCanvas.bound.maxY - gridCanvas.displayRect.minY) / boundHeight;\n        this.horizontalBar.setLowerRange(minX);\n        this.horizontalBar.setUpperRange(maxX);\n        this.verticalBar.setLowerRange(minY);\n        this.verticalBar.setUpperRange(maxY);\n    };\n    UIOverlay.prototype.syncViewByHorizontal = function () {\n        var gridCanvas = this.gridCanvas;\n        var lower = this.horizontalBar.lowerRange;\n        var upper = this.horizontalBar.upperRange;\n        var minX = lower * (gridCanvas.bound.maxX - gridCanvas.bound.minX) + gridCanvas.bound.minX;\n        var maxX = upper * (gridCanvas.bound.maxX - gridCanvas.bound.minX) + gridCanvas.bound.minX;\n        gridCanvas.displayRect.setMinX(minX);\n        gridCanvas.displayRect.setMaxX(maxX);\n        if (gridCanvas.aspectLocked) {\n            var displayAspect = gridCanvas.gridLayer.width / gridCanvas.gridLayer.height;\n            var verticalDiff = (maxX - minX) / displayAspect;\n            var verticalMid = (gridCanvas.displayRect.minY + gridCanvas.displayRect.maxY) / 2;\n            if (verticalMid - verticalDiff / 2 < gridCanvas.bound.minY) {\n                gridCanvas.displayRect.setMinY(gridCanvas.bound.minY);\n                gridCanvas.displayRect.setMaxY(gridCanvas.bound.minY + verticalDiff);\n                gridCanvas.display();\n            }\n            else if (verticalMid + verticalDiff / 2 > gridCanvas.bound.maxY) {\n                gridCanvas.displayRect.setMinY(gridCanvas.bound.maxY - verticalDiff);\n                gridCanvas.displayRect.setMaxY(gridCanvas.bound.maxY);\n                gridCanvas.display();\n            }\n            else {\n                gridCanvas.displayRect.setMinY(verticalMid - verticalDiff / 2);\n                gridCanvas.displayRect.setMaxY(verticalMid + verticalDiff / 2);\n                gridCanvas.display();\n            }\n        }\n        this.verticalBar.setLowerRange((gridCanvas.bound.maxY - gridCanvas.displayRect.maxY) / (gridCanvas.bound.maxY - gridCanvas.bound.minY));\n        this.verticalBar.setUpperRange((gridCanvas.bound.maxY - gridCanvas.displayRect.minY) / (gridCanvas.bound.maxY - gridCanvas.bound.minY));\n    };\n    UIOverlay.prototype.syncViewByVertical = function () {\n        var gridCanvas = this.gridCanvas;\n        var lower = 1 - this.verticalBar.upperRange;\n        var upper = 1 - this.verticalBar.lowerRange;\n        var minY = lower * (gridCanvas.bound.maxY - gridCanvas.bound.minY) + gridCanvas.bound.minY;\n        var maxY = upper * (gridCanvas.bound.maxY - gridCanvas.bound.minY) + gridCanvas.bound.minY;\n        gridCanvas.displayRect.setMinY(minY);\n        gridCanvas.displayRect.setMaxY(maxY);\n        if (gridCanvas.aspectLocked) {\n            var displayAspect = gridCanvas.gridLayer.width / gridCanvas.gridLayer.height;\n            var horizontalDiff = (maxY - minY) * displayAspect;\n            var horizontalMid = (gridCanvas.displayRect.minX + gridCanvas.displayRect.maxX) / 2;\n            if (horizontalMid - horizontalDiff / 2 < gridCanvas.bound.minX) {\n                gridCanvas.displayRect.setMinX(gridCanvas.bound.minX);\n                gridCanvas.displayRect.setMaxX(gridCanvas.bound.minX + horizontalDiff);\n                gridCanvas.display();\n            }\n            else if (horizontalMid + horizontalDiff / 2 > gridCanvas.bound.maxX) {\n                gridCanvas.displayRect.setMinX(gridCanvas.bound.maxX - horizontalDiff);\n                gridCanvas.displayRect.setMaxX(gridCanvas.bound.maxX);\n                gridCanvas.display();\n            }\n            else {\n                gridCanvas.displayRect.setMinX(horizontalMid - horizontalDiff / 2);\n                gridCanvas.displayRect.setMaxX(horizontalMid + horizontalDiff / 2);\n                gridCanvas.display();\n            }\n        }\n        this.horizontalBar.setLowerRange((gridCanvas.displayRect.minX - gridCanvas.bound.minX) / (gridCanvas.bound.maxX - gridCanvas.bound.minX));\n        this.horizontalBar.setUpperRange((gridCanvas.displayRect.maxX - gridCanvas.bound.minX) / (gridCanvas.bound.maxX - gridCanvas.bound.minX));\n    };\n    return UIOverlay;\n}());\nexports.default = UIOverlay;\n\n\n//# sourceURL=webpack://gridcanvas/./src/UiController.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GridCanvas_1 = __importDefault(__webpack_require__(/*! ./GridCanvas */ \"./src/GridCanvas.ts\"));\n(function checkWhenImported() {\n    if (typeof window === 'undefined')\n        throw Error('Grid canvas only works on a browser.\\nPlease check out if your configuration is correct.');\n})();\nwindow.GridCanvas = GridCanvas_1.default;\nexports.default = GridCanvas_1.default;\n\n\n//# sourceURL=webpack://gridcanvas/./src/index.ts?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader!./style.css */ \"./node_modules/css-loader/index.js!./src/style.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack://gridcanvas/./src/style.css?");

/***/ })

/******/ });
});